{
  "@openzeppelin/contracts": [
    {
      "title": "ERC2771Context with custom forwarder may lead to zero-valued _msgSender",
      "vulnerable_versions": [">=4.0.0 <4.9.3"],
      "description": "Contracts using ERC2771Context along with a custom trusted forwarder may see _msgSender return address(0) in calls that originate from the forwarder with calldata shorter than 20 bytes. This combination of circumstances does not appear to be common, in particular it is not the case for MinimalForwarder from OpenZeppelin Contracts, or any deployed forwarder the team is aware of, given that the signer address is appended to all calls that originate from these forwarders.",
      "patched_versions": ["4.9.3"],
      "link": "https://github.com/advisories/GHSA-g4vp-m682-qqmp"
    },
    {
      "title": "MerkleProof multiproofs may allow proving arbitrary leaves for specific trees",
      "vulnerable_versions": [">=4.7.0 <4.9.2"],
      "description": "When the verifyMultiProof, verifyMultiProofCalldata, processMultiProof, or processMultiProofCalldata functions are in use, it is possible to construct merkle trees that allow forging a valid multiproof for an arbitrary set of leaves. A contract may be vulnerable if it uses multiproofs for verification and the merkle tree that is processed includes a node with value 0 at depth 1 (just under the root). This could happen inadvertently for balanced trees with 3 leaves or less, if the leaves are not hashed. This could happen deliberately if a malicious tree builder includes such a node in the tree. A contract is not vulnerable if it uses single-leaf proving (verify, verifyCalldata, processProof, or processProofCalldata), or if it uses multiproofs with a known tree that has hashed leaves. Standard merkle trees produced or validated with the @openzeppelin/merkle-tree library are safe.",
      "patched_versions": ["4.9.2"],
      "link": "https://github.com/advisories/GHSA-wprv-93r4-jj2p"
    },
    {
      "title": "Governor proposal creation may be blocked by frontrunning",
      "vulnerable_versions": [">=4.3.0 <4.9.1"],
      "description": "By frontrunning the creation of a proposal, an attacker can become the proposer and gain the ability to cancel it. The attacker can do this repeatedly to try to prevent a proposal from being proposed at all. This impacts the Governor contract in v4.9.0 only, and the GovernorCompatibilityBravo contract since v4.3.0.",
      "patched_versions": "4.9.1",
      "link": "https://github.com/advisories/GHSA-5h3x-9wvq-w4m2"
    },
    {
      "title": "TransparentUpgradeableProxy clashing selector calls may not be delegated",
      "vulnerable_versions": [">=3.2.0 <4.8.3"],
      "description": "A function in the implementation contract may be inaccessible if its selector clashes with one of the proxy's own selectors. Specifically, if the clashing function has a different signature with incompatible ABI encoding, the proxy could revert while attempting to decode the arguments from calldata. The probability of an accidental clash is negligible, but one could be caused deliberately.",
      "patched_versions": "4.8.3",
      "link": "https://github.com/advisories/GHSA-mx2q-35m2-x2rh"
    },
    {
      "title": "GovernorCompatibilityBravo may trim proposal calldata",
      "vulnerable_versions": [">=4.3.0 <4.8.3"],
      "description": "The proposal creation entrypoint (propose) in GovernorCompatibilityBravo allows the creation of proposals with a signatures array shorter than the calldatas array. This causes the additional elements of the latter to be ignored, and if the proposal succeeds the corresponding actions would eventually execute without any calldata. The ProposalCreated event correctly represents what will eventually execute, but the proposal parameters as queried through getActions appear to respect the original intended calldata.",
      "patched_versions": "4.8.3",
      "link": "https://github.com/advisories/GHSA-93hq-5wgc-jc82"
    },
    {
      "title": "ERC721Consecutive incorrect balance update with batch of 1",
      "vulnerable_versions": [">=4.8.0 <4.8.2"],
      "description": "The ERC721Consecutive contract designed for minting NFTs in batches does not update balances when a batch has size 1 and consists of a single token. Subsequent transfers from the receiver of that token may overflow the balance as reported by balanceOf. The issue exclusively presents with batches of size 1.",
      "patched_versions": "4.8.2",
      "link": "https://github.com/advisories/GHSA-878m-3g6q-594q"
    },
    {
      "title": "ECDSA signature malleability",
      "vulnerable_versions": [">= 4.1.0 < 4.7.3"],
      "description": "The functions ECDSA.recover and ECDSA.tryRecover are vulnerable to a kind of signature malleability due to accepting EIP-2098 compact signatures in addition to the traditional 65 byte signature format. This is only an issue for the functions that take a single bytes argument, and not the functions that take r, v, s or r, vs as separate arguments. The potentially affected contracts are those that implement signature reuse or replay protection by marking the signature itself as used rather than the signed message or a nonce included in it. A user may take a signature that has already been submitted, submit it again in a different form, and bypass this protection.",
      "patched_versions": "4.7.3",
      "link": "https://github.com/advisories/GHSA-4h98-2769-gh6h"
    },
    {
      "title": "Cross chain utilities for Arbitrum L2 see EOA calls as cross chain calls",
      "vulnerable_versions": [">= 4.6.0 < 4.7.2"],
      "description": "Contracts using the cross chain utilies for Arbitrum L2, CrossChainEnabledArbitrumL2 or LibArbitrumL2, will classify direct interactions of externally owned accounts (EOAs) as cross chain calls, even though they are not started on L1. This is assessed as low severity because any action taken by an EOA on the contract could also be taken by the EOA through the bridge if the issue was not present.",
      "patched_versions": "4.7.2",
      "link": "https://github.com/advisories/GHSA-9j3m-g383-29qr"
    },
    {
      "title": "GovernorVotesQuorumFraction updates to quorum may affect past defeated proposals",
      "vulnerable_versions": [">= 4.3.0 < 4.7.2"],
      "description": "This issue concerns instances of Governor that use the module GovernorVotesQuorumFraction, a mechanism that determines quorum requirements as a percentage of the voting token's total supply. In affected instances, when a proposal is passed to lower the quorum requirement, past proposals may become executable if they had been defeated only due to lack of quorum, and the number of votes it received meets the new quorum requirement.",
      "patched_versions": "4.7.2",
      "link": "https://github.com/advisories/GHSA-xrc4-737v-9q75"
    },
    {
      "title": "ERC165Checker unbounded gas consumption",
      "vulnerable_versions": [">=2.0.0 < 4.7.2"],
      "description": "The target contract of an EIP-165 supportsInterface query can cause unbounded gas consumption by returning a lot of data, while it is generally assumed that this operation has a bounded cost.",
      "patched_versions": "4.7.2",
      "link": "https://github.com/advisories/GHSA-7grf-83vw-6f5x"
    },
    {
      "title": "SignatureChecker may revert on invalid EIP-1271 signers",
      "vulnerable_versions": [">= 4.1.0 <4.7.1"],
      "description": "SignatureChecker.isValidSignatureNow is not expected to revert. However, an incorrect assumption about Solidity 0.8's abi.decode allows some cases to revert, given a target contract that doesn't implement EIP-1271 as expected. The contracts that may be affected are those that use SignatureChecker to check the validity of a signature and handle invalid signatures in a way other than reverting. We believe this to be unlikely.",
      "patched_versions": "4.7.1",
      "link": "https://github.com/advisories/GHSA-4g63-c64m-25w9"
    },
    {
      "title": "ERC165Checker may revert instead of returning false",
      "vulnerable_versions": [">=4.0.0 <4.7.1"],
      "description": "ERC165Checker.supportsInterface is designed to always successfully return a boolean, and under no circumstance revert. However, an incorrect assumption about Solidity 0.8's abi.decode allows some cases to revert, given a target contract that doesn't implement EIP-165 as expected, specifically if it returns a value other than 0 or 1. The contracts that may be affected are those that use ERC165Checker to check for support for an interface and then handle the lack of support in a way other than reverting.",
      "patched_versions": "4.7.1",
      "link": "https://github.com/advisories/GHSA-qh9x-gcfh-pcrw"
    },
    {
      "title": "GovernorCompatibilityBravo incorrect ABI encoding may lead to unexpected behavior",
      "vulnerable_versions": [">=4.3.0 <4.4.2"],
      "description": "The GovernorCompatibilityBravo module may lead to the creation of governance proposals that execute function calls with incorrect arguments due to bad ABI encoding. This happens if the proposal is created using explicit function signatures, e.g. a proposal to invoke the function foo(uint256) is created as propose([target], [0], [\"foo(uint256)\"], [\"0x00..01\"]). If the function selector is provided as part of the encoded proposal data the issue is not present, e.g. the same proposal is created as propose([target], [0], [\"0x2fbebd3800..01\"]), where 2fbebd38 is the function selector.",
      "patched_versions": "4.4.2",
      "link": "URL_TO_THE_PUBLISHED_VULNERABILITY_DETAILS"
    },
    {
      "title": "Initializer reentrancy may lead to double initialization",
      "vulnerable_versions": [">=3.2.0 <4.4.1"],
      "description": "Initializer functions that are invoked separate from contract creation (the most prominent example being minimal proxies) may be reentered if they make an untrusted non-view external call. Once an initializer has finished running it can never be re-executed. However, an exception put in place to support multiple inheritance made reentrancy possible in the scenario described above, breaking the expectation that there is a single execution. Note that upgradeable proxies are commonly initialized together with contract creation, where reentrancy is not feasible, so the impact of this issue is believed to be minor.",
      "patched_versions": "4.4.1",
      "link": "URL_TO_THE_PUBLISHED_VULNERABILITY_DETAILS"
    },
    {
      "title": "ERC1155Supply vulnerability in OpenZeppelin Contracts",
      "vulnerable_versions": [">= 4.2.0 < 4.3.3"],
      "description": "When ERC1155 tokens are minted, a callback is invoked on the receiver of those tokens, as required by the spec. When including the ERC1155Supply extension, total supply is not updated until after the callback, thus during the callback the reported total supply is lower than the real number of tokens in circulation. If a system relies on accurately reported supply, an attacker may be able to mint tokens and invoke that system after receiving the token balance but before the supply is updated.",
      "patched_versions": "4.3.3",
      "link": "URL_TO_THE_PUBLISHED_VULNERABILITY_DETAILS"
    },
    {
      "title": "UUPSUpgradeable vulnerability in OpenZeppelin Contracts",
      "vulnerable_versions": [">= 4.1.0 < 4.3.2"],
      "description": "Upgradeable contracts using UUPSUpgradeable may be vulnerable to an attack affecting uninitialized implementation contracts. We will update this advisory with more information soon.",
      "patched_versions": "4.3.2",
      "link": "URL_TO_THE_PUBLISHED_VULNERABILITY_DETAILS"
    },
    {
      "title": "TimelockController vulnerability in OpenZeppelin Contracts",
      "vulnerable_versions": [
        ">=4.0.0 <=4.3.0",
        ">=3.3.0 <=3.4.1",
        "3.3.0-solc-0.7",
        "3.4.0-solc-0.7",
        "3.4.1-solc-0.7-2"
      ],
      "description": "A vulnerability in TimelockController allowed an actor with the executor role to take immediate control of the timelock, by resetting the delay to 0 and escalating privileges, thus gaining unrestricted access to assets held in the contract. Instances with the executor role set to \"open\" allow anyone to use the executor role, thus leaving the timelock at risk of being taken over by an attacker.",
      "patched_versions": ["4.3.1", "3.4.2", "3.4.2-solc-0.7"],
      "link": "URL_TO_THE_PUBLISHED_VULNERABILITY_DETAILS"
    }
  ],
  "@openzeppelin/contracts-upgradeable": [
    {
      "title": "ERC2771Context with custom forwarder may lead to zero-valued _msgSender",
      "vulnerable_versions": [">=4.0.0 <4.9.3"],
      "description": "...",
      "patched_versions": "4.9.3",
      "link": "https://github.com/advisories/GHSA-g4vp-m682-qqmp"
    },
    {
      "title": "MerkleProof multiproofs may allow proving arbitrary leaves for specific trees",
      "vulnerable_versions": [">=4.7.0 <4.9.2"],
      "description": "When the verifyMultiProof, verifyMultiProofCalldata, processMultiProof, or processMultiProofCalldata functions are in use, it is possible to construct merkle trees that allow forging a valid multiproof for an arbitrary set of leaves. A contract may be vulnerable if it uses multiproofs for verification and the merkle tree that is processed includes a node with value 0 at depth 1 (just under the root). This could happen inadvertently for balanced trees with 3 leaves or less, if the leaves are not hashed. This could happen deliberately if a malicious tree builder includes such a node in the tree. A contract is not vulnerable if it uses single-leaf proving (verify, verifyCalldata, processProof, or processProofCalldata), or if it uses multiproofs with a known tree that has hashed leaves. Standard merkle trees produced or validated with the @openzeppelin/merkle-tree library are safe.",
      "patched_versions": ["4.9.2"],
      "link": "https://github.com/advisories/GHSA-wprv-93r4-jj2p"
    },
    {
      "title": "Governor proposal creation may be blocked by frontrunning",
      "vulnerable_versions": [">=4.3.0 <4.9.1"],
      "description": "By frontrunning the creation of a proposal, an attacker can become the proposer and gain the ability to cancel it. The attacker can do this repeatedly to try to prevent a proposal from being proposed at all. This impacts the Governor contract in v4.9.0 only, and the GovernorCompatibilityBravo contract since v4.3.0.",
      "patched_versions": "4.9.1",
      "link": "https://github.com/advisories/GHSA-5h3x-9wvq-w4m2"
    },
    {
      "title": "TransparentUpgradeableProxy clashing selector calls may not be delegated",
      "vulnerable_versions": [">=3.2.0 <4.8.3"],
      "description": "A function in the implementation contract may be inaccessible if its selector clashes with one of the proxy's own selectors. Specifically, if the clashing function has a different signature with incompatible ABI encoding, the proxy could revert while attempting to decode the arguments from calldata. The probability of an accidental clash is negligible, but one could be caused deliberately.",
      "patched_versions": "4.8.3",
      "link": "https://github.com/advisories/GHSA-mx2q-35m2-x2rh"
    },
    {
      "title": "GovernorCompatibilityBravo may trim proposal calldata",
      "vulnerable_versions": [">=4.3.0 <4.8.3"],
      "description": "The proposal creation entrypoint (propose) in GovernorCompatibilityBravo allows the creation of proposals with a signatures array shorter than the calldatas array. This causes the additional elements of the latter to be ignored, and if the proposal succeeds the corresponding actions would eventually execute without any calldata. The ProposalCreated event correctly represents what will eventually execute, but the proposal parameters as queried through getActions appear to respect the original intended calldata.",
      "patched_versions": "4.8.3",
      "link": "https://github.com/advisories/GHSA-93hq-5wgc-jc82"
    },
    {
      "title": "ERC721Consecutive incorrect balance update with batch of 1",
      "vulnerable_versions": [">=4.8.0 <4.8.2"],
      "description": "The ERC721Consecutive contract designed for minting NFTs in batches does not update balances when a batch has size 1 and consists of a single token. Subsequent transfers from the receiver of that token may overflow the balance as reported by balanceOf. The issue exclusively presents with batches of size 1.",
      "patched_versions": "4.8.2",
      "link": "https://github.com/advisories/GHSA-878m-3g6q-594q"
    },
    {
      "title": "ECDSA signature malleability",
      "vulnerable_versions": [">= 4.1.0 < 4.7.3"],
      "description": "The functions ECDSA.recover and ECDSA.tryRecover are vulnerable to a kind of signature malleability due to accepting EIP-2098 compact signatures in addition to the traditional 65 byte signature format. This is only an issue for the functions that take a single bytes argument, and not the functions that take r, v, s or r, vs as separate arguments. The potentially affected contracts are those that implement signature reuse or replay protection by marking the signature itself as used rather than the signed message or a nonce included in it. A user may take a signature that has already been submitted, submit it again in a different form, and bypass this protection.",
      "patched_versions": "4.7.3",
      "link": "https://github.com/advisories/GHSA-4h98-2769-gh6h"
    },
    {
      "title": "Cross chain utilities for Arbitrum L2 see EOA calls as cross chain calls",
      "vulnerable_versions": [">= 4.6.0 < 4.7.2"],
      "description": "Contracts using the cross chain utilies for Arbitrum L2, CrossChainEnabledArbitrumL2 or LibArbitrumL2, will classify direct interactions of externally owned accounts (EOAs) as cross chain calls, even though they are not started on L1. This is assessed as low severity because any action taken by an EOA on the contract could also be taken by the EOA through the bridge if the issue was not present.",
      "patched_versions": "4.7.2",
      "link": "https://github.com/advisories/GHSA-9j3m-g383-29qr"
    },
    {
      "title": "GovernorVotesQuorumFraction updates to quorum may affect past defeated proposals",
      "vulnerable_versions": [">= 4.3.0 < 4.7.2"],
      "description": "This issue concerns instances of Governor that use the module GovernorVotesQuorumFraction, a mechanism that determines quorum requirements as a percentage of the voting token's total supply. In affected instances, when a proposal is passed to lower the quorum requirement, past proposals may become executable if they had been defeated only due to lack of quorum, and the number of votes it received meets the new quorum requirement.",
      "patched_versions": "4.7.2",
      "link": "https://github.com/advisories/GHSA-xrc4-737v-9q75"
    },
    {
      "title": "ERC165Checker unbounded gas consumption",
      "vulnerable_versions": [">=3.2.0 < 4.7.2"],
      "description": "The target contract of an EIP-165 supportsInterface query can cause unbounded gas consumption by returning a lot of data, while it is generally assumed that this operation has a bounded cost.",
      "patched_versions": "4.7.2",
      "link": "https://github.com/advisories/GHSA-7grf-83vw-6f5x"
    },
    {
      "title": "SignatureChecker may revert on invalid EIP-1271 signers",
      "vulnerable_versions": [">= 4.1.0 <4.7.1"],
      "description": "SignatureChecker.isValidSignatureNow is not expected to revert. However, an incorrect assumption about Solidity 0.8's abi.decode allows some cases to revert, given a target contract that doesn't implement EIP-1271 as expected. The contracts that may be affected are those that use SignatureChecker to check the validity of a signature and handle invalid signatures in a way other than reverting. We believe this to be unlikely.",
      "patched_versions": "4.7.1",
      "link": "https://github.com/advisories/GHSA-4g63-c64m-25w9"
    },
    {
      "title": "ERC165Checker may revert instead of returning false",
      "vulnerable_versions": [">=4.0.0 <4.7.1"],
      "description": "ERC165Checker.supportsInterface is designed to always successfully return a boolean, and under no circumstance revert. However, an incorrect assumption about Solidity 0.8's abi.decode allows some cases to revert, given a target contract that doesn't implement EIP-165 as expected, specifically if it returns a value other than 0 or 1. The contracts that may be affected are those that use ERC165Checker to check for support for an interface and then handle the lack of support in a way other than reverting.",
      "patched_versions": "4.7.1",
      "link": "https://github.com/advisories/GHSA-qh9x-gcfh-pcrw"
    },
    {
      "title": "GovernorCompatibilityBravo incorrect ABI encoding may lead to unexpected behavior",
      "vulnerable_versions": [">=4.3.0 <4.4.2"],
      "description": "The GovernorCompatibilityBravo module may lead to the creation of governance proposals that execute function calls with incorrect arguments due to bad ABI encoding. This happens if the proposal is created using explicit function signatures, e.g. a proposal to invoke the function foo(uint256) is created as propose([target], [0], [\"foo(uint256)\"], [\"0x00..01\"]). If the function selector is provided as part of the encoded proposal data the issue is not present, e.g. the same proposal is created as propose([target], [0], [\"0x2fbebd3800..01\"]), where 2fbebd38 is the function selector.",
      "patched_versions": "4.4.2",
      "link": "URL_TO_THE_PUBLISHED_VULNERABILITY_DETAILS"
    },
    {
      "title": "Initializer reentrancy may lead to double initialization",
      "vulnerable_versions": [">=3.2.0 <4.4.1"],
      "description": "Initializer functions that are invoked separate from contract creation (the most prominent example being minimal proxies) may be reentered if they make an untrusted non-view external call. Once an initializer has finished running it can never be re-executed. However, an exception put in place to support multiple inheritance made reentrancy possible in the scenario described above, breaking the expectation that there is a single execution. Note that upgradeable proxies are commonly initialized together with contract creation, where reentrancy is not feasible, so the impact of this issue is believed to be minor.",
      "patched_versions": "4.4.1",
      "link": "URL_TO_THE_PUBLISHED_VULNERABILITY_DETAILS"
    },
    {
      "title": "ERC1155Supply vulnerability in OpenZeppelin Contracts",
      "vulnerable_versions": [">= 4.2.0 < 4.3.3"],
      "description": "When ERC1155 tokens are minted, a callback is invoked on the receiver of those tokens, as required by the spec. When including the ERC1155Supply extension, total supply is not updated until after the callback, thus during the callback the reported total supply is lower than the real number of tokens in circulation. If a system relies on accurately reported supply, an attacker may be able to mint tokens and invoke that system after receiving the token balance but before the supply is updated.",
      "patched_versions": "4.3.3",
      "link": "URL_TO_THE_PUBLISHED_VULNERABILITY_DETAILS"
    },
    {
      "title": "UUPSUpgradeable vulnerability in OpenZeppelin Contracts",
      "vulnerable_versions": [">= 4.1.0 < 4.3.2"],
      "description": "Upgradeable contracts using UUPSUpgradeable may be vulnerable to an attack affecting uninitialized implementation contracts. We will update this advisory with more information soon.",
      "patched_versions": "4.3.2",
      "link": "URL_TO_THE_PUBLISHED_VULNERABILITY_DETAILS"
    },
    {
      "title": "TimelockController vulnerability in OpenZeppelin Contracts",
      "vulnerable_versions": [
        ">=4.0.0 <=4.3.0",
        ">=3.3.0 <=3.4.1",
        "3.3.0-solc-0.7",
        "3.4.0-solc-0.7",
        "3.4.1-solc-0.7-2"
      ],
      "description": "A vulnerability in TimelockController allowed an actor with the executor role to take immediate control of the timelock, by resetting the delay to 0 and escalating privileges, thus gaining unrestricted access to assets held in the contract. Instances with the executor role set to \"open\" allow anyone to use the executor role, thus leaving the timelock at risk of being taken over by an attacker.",
      "patched_versions": ["4.3.1", "3.4.2", "3.4.2-solc-0.7"],
      "link": "URL_TO_THE_PUBLISHED_VULNERABILITY_DETAILS"
    },
    {
      "title": "ERC2771Context with custom forwarder may lead to zero-valued _msgSender",
      "vulnerable_versions": [">=4.0.0 <4.9.3"],
      "description": "Contracts using ERC2771Context along with a custom trusted forwarder may see _msgSender return address(0) in calls that originate from the forwarder with calldata shorter than 20 bytes. This combination of circumstances does not appear to be common, in particular it is not the case for MinimalForwarder from OpenZeppelin Contracts, or any deployed forwarder the team is aware of, given that the signer address is appended to all calls that originate from these forwarders.",
      "patched_versions": ["4.9.3"],
      "link": "https://github.com/advisories/GHSA-g4vp-m682-qqmp"
    }
  ],
  "openzeppelin-eth": [
    {
      "title": "ERC165Checker unbounded gas consumption",
      "vulnerable_versions": [">=2.0.0"],
      "description": "The target contract of an EIP-165 supportsInterface query can cause unbounded gas consumption by returning a lot of data, while it is generally assumed that this operation has a bounded cost.",
      "patched_versions": "None",
      "link": "https://github.com/advisories/GHSA-7grf-83vw-6f5x"
    }
  ],
  "openzeppelin-solidity": [
    {
      "title": "ERC165Checker unbounded gas consumption",
      "vulnerable_versions": [">=2.0.0"],
      "description": "The target contract of an EIP-165 supportsInterface query can cause unbounded gas consumption by returning a lot of data, while it is generally assumed that this operation has a bounded cost.",
      "patched_versions": "None",
      "link": "https://github.com/advisories/GHSA-7grf-83vw-6f5x"
    }
  ]
}
